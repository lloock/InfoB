/**
 * A Stack that holds Strings. Works after the LIFO (Last in first out)
 * principle.
 *
 * @author Mathias Menninghaus (mathias.menninghaus@uos.de)
 *
 */
public class StringStack {

   public StringStack() {
      this.first = null;
   }

   private StringStackEntry first;

   /***********************************snip 8<**********************/
   // Copy Constructor (shallow copy), but since its a stack behaves like deep copy
   public StringStack(StringStack stack) {
     this.first = stack.first;
   }

   /************************************snap -8 ***********************/
   /**
    * Tests, whether this StringStack is empty or not.
    *
    * @return true if this StringStack is empty, else false
    */
   public boolean empty() {
      return this.first == null;
   }

   /**
    * Returns the first element in the stack. Throws Exception when stack is
    * empty
    *
    * @return First element or null if stack is empty
    * @throws RuntimeException
    *            if stack is empty.
    */
   public String peek() {
      if (!this.empty()) {
         return first.getString();
      } else {
         throw new RuntimeException("Stack is empty");
      }
   }

   /**
    * Deletes the first element in the stack and returns it. Throws Exception
    * when stack is empty
    *
    * @return first element in the stack
    * @throws RuntimeException
    *            if stack is empty.
    */
   public String pop() {
      if (!this.empty()) {
         String ret = first.getString();
         this.first = this.first.getNext();
         return ret;
      } else {
         throw new RuntimeException("Stack is empty");
      }
   }

   /**
    * Puts the String s on the stack.
    *
    * @param s
    *           String to be added.
    */
   public void push(String s) {
      if (this.empty()) {
         first = new StringStackEntry(s, null);
      } else {
         first = new StringStackEntry(s, first);
      }
   }

}
/*********************************************************************************************/

/**
 * Represents an entry of a <code>StringStack</code> which holds a String and a
 * reference to the next StringStackEntry.
 *
 * @author Mathias Menninghaus (mathias.menninghaus@uos.de)
 *
 */
class StringStackEntry {

   /**
    * The next StringStackEntry
    */
   private StringStackEntry next;
   /**
    * The String which this StringStackEntry represents
    */
   private String s;

   /**
    * @param s
    *           String in Stack which is represented by this StringStackEntry
    */
   StringStackEntry(String s) {
      this(s, null);
   }

   /**
    *
    * @param s
    *           String in Stack which is represented by this StringStackEntry
    * @param next
    *           the StringStackEntry next will be visible if this
    *           StringStackEntry is removed from the stack.
    */
   StringStackEntry(String s, StringStackEntry next) {
      this.s = s;
      this.next = next;
   }

   StringStackEntry getNext() {
      return this.next;
   }

   String getString() {
      return this.s;
   }


}

/*********************************************************************************************/

public class TestStringStack{
  public static void main(String[] args) {

    String[] abc = {"A", "B", "C"};

    StringStack reference = new StringStack();
    for(int i = 1; i < abc.length; i++) {
      reference.push(abc[i]);
    }

    StringStack copy = new StringStack(reference);

    System.out.println("reference_peek = " + reference.peek());
    System.out.println("copy_peek = " + copy.peek());

    copy.pop();
    System.out.println("One element from the copy was popped.");
    System.out.println("reference_peek = " + reference.peek());
    System.out.println("copy_peek = " + copy.peek());
    System.out.println();

    copy.push("X");
    System.out.println("One element was pushed to the copy StringStack.");
    System.out.println("reference_peek = " + reference.peek());
    System.out.println("copy_peek = " + copy.peek());

  }
}



